<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>VLD Staking</title>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
<style>
  :root{
    --bg:#0b1120;
    --card:#0f172a;
    --text:#d0d0d0;
    --muted:#94a3b8;
    --primary:#3b82f6;
    --warn:#facc15;
    --error:#f87171;
    --ok:#22c55e;
  }
  *{box-sizing:border-box}
  body{
    font-family:'Roboto',sans-serif;
    background-color:var(--bg);
    color:var(--text);
    margin:0;
    padding:2rem;
  }
  h1{font-size:2rem;margin:0 0 1rem 0;text-align:center}
  .topbar{position:sticky;top:0;display:flex;justify-content:flex-end;gap:.5rem;align-items:center;background:linear-gradient(180deg, rgba(11,17,32,0.95), rgba(11,17,32,0));padding:.5rem 0 1rem 0}
  button{
    background-color:var(--primary);
    color:white;border:none;padding:.6rem 1rem;border-radius:10px;
    font-weight:bold;cursor:pointer;transition:transform .06s ease,opacity .2s;
  }
  button:disabled{opacity:.6;cursor:not-allowed;transform:none}
  input[type="number"]{
    padding:.6rem;font-size:1rem;border-radius:10px;border:1px solid #334155;background:#0b1328;color:var(--text);
  }
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:1rem;margin-top:1rem}
  .card{background:var(--card);border-radius:16px;padding:1rem;box-shadow:0 10px 30px rgba(0,0,0,.35)}
  .muted{color:var(--muted);font-size:.95rem}
  .note{color:var(--warn);font-size:.95rem;margin-top:.5rem}
  .error{color:var(--error);font-weight:700}
  .ok{color:var(--ok);font-weight:700}
  .row{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap}
  .stat{font-size:1.1rem;margin:.25rem 0}
  .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, monospace;background:#0b1328;border:1px solid #334155;border-radius:6px;padding:.1rem .4rem}
  .spinner{display:none;margin-left:.5rem;border:3px solid #1e293b;border-top:3px solid #fff;border-radius:50%;width:16px;height:16px;animation:spin 0.8s linear infinite}
  @keyframes spin{from{transform:rotate(0)}to{transform:rotate(360deg)}}
  .footer{margin-top:1rem;text-align:center;color:var(--muted);font-size:.85rem}
  .link{color:#93c5fd;text-decoration:none}
</style>
</head>
<body>
  <div class="topbar">
    <span>üåê</span>
    <button data-i18n="lang_ita" onclick="updateLanguage('it')">ITA</button>
    <button data-i18n="lang_eng" onclick="updateLanguage('en')">ENG</button>
  </div>

  <h1 data-i18n="title">VLD Staking Interface 1.06</h1>

  <div class="grid">
    <div class="card">
      <div class="row" style="justify-content:space-between">
        <button id="connect" data-i18n="connect">üîó Connetti Wallet</button>
        <div class="row">
          <span id="net" class="muted">‚Äî</span>
          <div id="busy" class="spinner"></div>
        </div>
      </div>
      <p id="account" class="muted" style="word-break:break-all"></p>
      <p id="warning" class="error"></p>
      <div id="funded" class="ok" style="display:none"></div>
    </div>

    <div class="card">
      <h3 data-i18n="stake_title">ü™ô Fai stake dei tuoi VLD</h3>
      <div class="row" style="margin:.5rem 0">
        <input id="amount" placeholder="Quantit√† VLD" type="number" min="0" step="any"/>
        <button id="maxBtn" title="Usa tutto il saldo">MAX</button>
        <button id="stake" data-i18n="stake_button">Stake</button>
      </div>
      <p class="note" data-i18n="stake_note">‚è≥ Periodo minimo di blocco: 30 giorni</p>
      <p class="muted stat" id="user-balance"></p>
      <p class="muted stat" id="user-staked"></p>
      <p class="muted stat" id="tvl"></p>
    </div>

    <div class="card">
      <h3 data-i18n="claim_title">üéÅ Claim reward</h3>
      <div class="row" style="margin:.5rem 0">
        <button id="claim" data-i18n="claim_button">Claim</button>
      </div>
      <p class="muted stat" id="estimated-reward"></p>
    </div>

    <div class="card">
      <h3 data-i18n="unstake_title">üîì Unstake</h3>
      <div class="row" style="margin:.5rem 0">
        <button id="unstake" data-i18n="unstake_button" disabled>Unstake</button>
      </div>
      <p class="muted stat" id="unstake-info"></p>
    </div>
  </div>

  <div class="footer">
    <span>VLD Staking UI v1.06 ‚Ä¢ Ethers.js 5 ‚Ä¢ BSC Mainnet</span>
  </div>

<script>
  // ====== Addresses ======
  const contractAddress = "0x9AA246af0B01D51D5a9e59c1DdECa6544B8A0198"; // Staking
  const tokenAddress    = "0xDF9387A2BF55F1e5b9f60599b6Ccbf6a5dA13A4b"; // VLD

  // ====== ABIs ======
  const abi = [
    "function stake(uint256 amount) public",
    "function claimReward() public",
    "function unstake() public",
    "function stakes(address) view returns (uint256 amount, uint256 startTime, uint256 lastClaim)",
    "function totalStaked() view returns (uint256)",
    "function lockPeriod() view returns (uint256)",
    "function annualRatePercent() view returns (uint256)"
  ];
  const tokenAbi = [
    "function approve(address spender, uint256 amount) public returns (bool)",
    "function balanceOf(address account) view returns (uint256)",
    "function allowance(address owner, address spender) view returns (uint256)",
    "function decimals() view returns (uint8)",
    "function symbol() view returns (string)"
  ];

  // ====== State ======
  let provider, signer, userAddress, stakingContract, tokenContract, tokenDecimals = 18, symbol = "VLD";
  let refreshTimer = null;
  let currentLang = localStorage.getItem("vld_lang") || "it";

  // ====== Helpers ======
  const $ = (id) => document.getElementById(id);
  const busy = (on)=> { $("busy").style.display = on ? "inline-block" : "none"; };
  const disableAll = (on)=> {
    ["stake","claim","unstake","connect","maxBtn"].forEach(id=>{
      const el=$(id); if(el){el.disabled=on;}
    });
  };
  function parseRevert(e){
    try{
      if(e && e.error && e.error.message) return e.error.message;
      if(e && e.data && e.data.message) return e.data.message;
      if(e && e.message) return e.message;
    }catch{}
    return "Transaction failed";
  }

  async function ensureBSC(){
    const net = await provider.getNetwork();
    if (net.chainId === 56){ $("net").innerText = "üü¢ BSC Mainnet (56)"; return; }
    $("net").innerText = `üîÅ Switch network (current id ${net.chainId})`;
    try {
      await window.ethereum.request({ method: "wallet_switchEthereumChain", params: [{ chainId: "0x38" }] });
      $("net").innerText = "üü¢ BSC Mainnet (56)";
    } catch (switchErr) {
      // If the chain is not added yet
      if (switchErr.code === 4902) {
        try {
          await window.ethereum.request({
            method: "wallet_addEthereumChain",
            params: [{
              chainId: "0x38",
              chainName: "BNB Smart Chain",
              nativeCurrency: { name:"BNB", symbol:"BNB", decimals:18 },
              rpcUrls: ["https://bsc-dataseed.binance.org/"],
              blockExplorerUrls: ["https://bscscan.com/"]
            }]
          });
          $("net").innerText = "üü¢ BSC Mainnet (56)";
        } catch (addErr) {
          alert(translations[currentLang].switch_failed);
        }
      } else {
        alert(translations[currentLang].switch_failed);
      }
    }
  }

  async function refreshUserData(){
    if(!stakingContract || !tokenContract || !userAddress) return;
    busy(true);
    try {
      const [userBalance, stakeInfo, lp, arp, tvl] = await Promise.all([
        tokenContract.balanceOf(userAddress),
        stakingContract.stakes(userAddress),
        stakingContract.lockPeriod(),
        stakingContract.annualRatePercent(),
        stakingContract.totalStaked()
      ]);

      $("user-balance").innerText = `${translations[currentLang].balance}: ${ethers.utils.formatUnits(userBalance, tokenDecimals)} ${symbol}`;
      $("user-staked").innerText  = `${translations[currentLang].staked}: ${ethers.utils.formatUnits(stakeInfo.amount, tokenDecimals)} ${symbol}`;
      $("tvl").innerText          = `${translations[currentLang].tvl}: ${ethers.utils.formatUnits(tvl, tokenDecimals)} ${symbol}`;

      // APY & lock period
      const days = Math.floor(lp.toNumber()/86400);
      const stakeNoteEl = document.querySelector('[data-i18n="stake_note"]');
      if (stakeNoteEl) {
        stakeNoteEl.innerText = `‚è≥ ${translations[currentLang].lock_period}: ${days} ${translations[currentLang].days} ‚Äî APY: ${arp.toString()}%`;
      }

      // Rewards estimate (UI-side; on-chain is canonical)
      const block = await signer.provider.getBlock("latest");
      const now = block.timestamp;
      const elapsedDays = Math.max(0, Math.floor((now - stakeInfo.lastClaim.toNumber()) / 86400));
      const rewardOutput = $("estimated-reward");

      if (!stakeInfo.amount.isZero() && elapsedDays > 0) {
        const estimated = stakeInfo.amount
          .mul(arp) // percent
          .mul(ethers.BigNumber.from(elapsedDays))
          .div(36500);
        if (estimated.gt(0)) {
          rewardOutput.innerText = `${translations[currentLang].reward_ready} ${ethers.utils.formatUnits(estimated, tokenDecimals)} ${symbol}`;
        } else {
          rewardOutput.innerText = translations[currentLang].reward_none;
        }
      } else {
        rewardOutput.innerText = translations[currentLang].reward_none;
      }

      // Unstake gating
      const unstakeBtn = $("unstake");
      const unstakeInfo = $("unstake-info");
      const unlockTime = stakeInfo.startTime.toNumber() + lp.toNumber();

      if (stakeInfo.amount.isZero()) {
        unstakeInfo.innerText = "";
        unstakeBtn.disabled = true;
      } else if (block.timestamp < unlockTime) {
        const unlockDate = new Date(unlockTime * 1000);
        unstakeInfo.innerText = `${translations[currentLang].unstake_locked} ${unlockDate.toLocaleDateString()}`;
        unstakeBtn.disabled = true;
      } else {
        unstakeInfo.innerText = translations[currentLang].unstake_now;
        unstakeBtn.disabled = false;
      }

      // Contract funded?
      const rewardFund = await tokenContract.balanceOf(contractAddress);
      if (rewardFund.eq(0)) {
        $("warning").innerText = translations[currentLang].contract_warning;
        $("funded").style.display = "none";
      } else {
        $("warning").innerText = "";
        $("funded").style.display = "block";
        $("funded").innerText = `${translations[currentLang].contract_funded} ${ethers.utils.formatUnits(rewardFund, tokenDecimals)} ${symbol}`;
      }
    } catch(err){
      console.error("refreshUserData", err);
    } finally {
      busy(false);
    }
  }

  function autoRefresh(start){
    if (start){
      if (refreshTimer) clearInterval(refreshTimer);
      refreshTimer = setInterval(refreshUserData, 20000);
    } else if (refreshTimer){
      clearInterval(refreshTimer);
      refreshTimer = null;
    }
  }

  // ====== Events ======
  $("connect").onclick = async () => {
    try {
      if (!window.ethereum) return alert(translations[currentLang].install_metamask);
      provider = new ethers.providers.Web3Provider(window.ethereum);
      await provider.send("eth_requestAccounts", []);
      await ensureBSC();

      signer = provider.getSigner();
      userAddress = await signer.getAddress();
      $("account").innerText = `${translations[currentLang].wallet_connected}${userAddress}`;

      stakingContract = new ethers.Contract(contractAddress, abi, signer);
      tokenContract   = new ethers.Contract(tokenAddress, tokenAbi, signer);

      try { tokenDecimals = await tokenContract.decimals(); } catch { tokenDecimals = 18; }
      try { symbol = await tokenContract.symbol(); } catch { symbol = "VLD"; }

      await refreshUserData();
      autoRefresh(true);
    } catch (error) {
      console.error("connect", error);
      alert(translations[currentLang].error_wallet + " ‚Äî " + parseRevert(error));
    }
  };

  $("maxBtn").onclick = async () => {
    try{
      if (!tokenContract || !userAddress) return;
      const bal = await tokenContract.balanceOf(userAddress);
      $("amount").value = ethers.utils.formatUnits(bal, tokenDecimals);
    }catch(e){ /* ignore */ }
  };

  $("stake").onclick = async () => {
    if (!stakingContract || !tokenContract) return alert(translations[currentLang].connect_first);
    const amountStr = $("amount").value.trim();
    if (!amountStr || isNaN(amountStr)) return alert(translations[currentLang].invalid_amount);
    const amountParsed = ethers.utils.parseUnits(amountStr, tokenDecimals);
    if (amountParsed.lte(0)) return alert(translations[currentLang].invalid_amount);

    disableAll(true); busy(true);
    try {
      const walletBalance  = await tokenContract.balanceOf(userAddress);
      if (walletBalance.lt(amountParsed)) throw new Error(translations[currentLang].insufficient_balance);

      // Approve once (MaxUint256) if needed
      const currentAllowance = await tokenContract.allowance(userAddress, contractAddress);
      if (currentAllowance.lt(amountParsed)) {
        const approveTx = await tokenContract.approve(contractAddress, ethers.constants.MaxUint256);
        await approveTx.wait();
      }

      // Gas estimate + 15% buffer
      let gasEstimate;
      try { gasEstimate = await stakingContract.estimateGas.stake(amountParsed); }
      catch { gasEstimate = ethers.BigNumber.from("200000"); }
      const gasLimit = gasEstimate.mul(115).div(100);

      const tx = await stakingContract.stake(amountParsed, { gasLimit });
      await tx.wait();
      alert(translations[currentLang].success_stake);
      $("amount").value = "";
      await refreshUserData();
    } catch (e) {
      console.error("stake", e);
      alert(translations[currentLang].error_stake + " ‚Äî " + parseRevert(e));
    } finally {
      disableAll(false); busy(false);
    }
  };

  $("claim").onclick = async () => {
    if (!stakingContract) return alert(translations[currentLang].connect_first);
    disableAll(true); busy(true);
    try {
      let gas; try { gas = await stakingContract.estimateGas.claimReward(); } catch{}
      const tx = await stakingContract.claimReward({ gasLimit: gas ? gas.mul(115).div(100) : undefined });
      await tx.wait();
      alert(translations[currentLang].success_claim);
      await refreshUserData();
    } catch (e) {
      console.error("claim", e);
      alert(translations[currentLang].error_claim + " ‚Äî " + parseRevert(e));
    } finally {
      disableAll(false); busy(false);
    }
  };

  $("unstake").onclick = async () => {
    if (!stakingContract) return alert(translations[currentLang].connect_first);
    disableAll(true); busy(true);
    try {
      let gas; try { gas = await stakingContract.estimateGas.unstake(); } catch{}
      const tx = await stakingContract.unstake({ gasLimit: gas ? gas.mul(115).div(100) : undefined });
      await tx.wait();
      alert(translations[currentLang].success_unstake);
      await refreshUserData();
    } catch (e) {
      console.error("unstake", e);
      alert(translations[currentLang].error_unstake + " ‚Äî " + parseRevert(e));
    } finally {
      disableAll(false); busy(false);
    }
  };

  // ====== i18n ======
  const translations = {
    it: {
      lang_ita:"ITA", lang_eng:"ENG",
      title:"Interfaccia VLD Staking 1.06",
      connect:"üîó Connetti Wallet",
      stake_title:"ü™ô Fai stake dei tuoi VLD",
      stake_note:"‚è≥ Periodo minimo di blocco: 30 giorni",
      stake_button:"Stake",
      unstake_title:"üîì Unstake",
      unstake_button:"Unstake",
      unstake_now:"‚úÖ Puoi fare unstake ora.",
      unstake_locked:"üîí Unstake disponibile dal:",
      claim_title:"üéÅ Claim reward",
      claim_button:"Claim",
      reward_ready:"üéØ Reward maturata:",
      reward_none:"üéØ Nessuna reward maturata al momento.",
      contract_warning:"‚ö†Ô∏è Il contratto non ha token VLD per i reward. Lo staking fallir√† finch√© non verr√† finanziato.",
      contract_funded:"üí∞ Fondi reward presenti nel contratto:",
      wallet_connected:"Wallet: ",
      balance:"Saldo",
      staked:"In staking",
      tvl:"Totale in staking (TVL)",
      lock_period:"Periodo minimo di blocco",
      days:"giorni",
      install_metamask:"Installa Metamask!",
      switch_failed:"Impossibile cambiare rete su MetaMask.",
      error_wallet:"Errore nella connessione al wallet.",
      error_claim:"Errore durante il claim",
      success_claim:"Reward ricevuta!",
      error_unstake:"Errore durante l'unstake",
      success_unstake:"Unstake completato!",
      error_stake:"Errore durante lo stake",
      success_stake:"Stake eseguito!",
      invalid_amount:"Inserisci un importo valido",
      insufficient_balance:"Saldo insufficiente per fare stake!",
      connect_first:"Devi prima connettere il wallet!"
    },
    en: {
      lang_ita:"ITA", lang_eng:"ENG",
      title:"VLD Staking Interface 1.06",
      connect:"üîó Connect Wallet",
      stake_title:"ü™ô Stake your VLD",
      stake_note:"‚è≥ Minimum lock period: 30 days",
      stake_button:"Stake",
      unstake_title:"üîì Unstake",
      unstake_button:"Unstake",
      unstake_now:"‚úÖ You can unstake now.",
      unstake_locked:"üîí Unstake available from:",
      claim_title:"üéÅ Claim reward",
      claim_button:"Claim",
      reward_ready:"üéØ Reward accrued:",
      reward_none:"üéØ No reward accrued yet.",
      contract_warning:"‚ö†Ô∏è Contract has no VLD tokens for rewards. Staking will fail until it is funded.",
      contract_funded:"üí∞ Reward funds in contract:",
      wallet_connected:"Wallet: ",
      balance:"Balance",
      staked:"Staked",
      tvl:"Total Staked (TVL)",
      lock_period:"Minimum lock period",
      days:"days",
      install_metamask:"Install Metamask!",
      switch_failed:"Failed to switch network in MetaMask.",
      error_wallet:"Error connecting wallet.",
      error_claim:"Error during claim",
      success_claim:"Reward claimed!",
      error_unstake:"Error during unstake",
      success_unstake:"Unstake completed!",
      error_stake:"Error during stake",
      success_stake:"Stake successful!",
      invalid_amount:"Please enter a valid amount",
      insufficient_balance:"Insufficient balance to stake!",
      connect_first:"You must connect your wallet first!"
    }
  };
  function updateLanguage(lang){
    currentLang = lang;
    localStorage.setItem("vld_lang", lang);
    document.querySelectorAll("[data-i18n]").forEach(el=>{
      const key = el.getAttribute("data-i18n");
      if (translations[lang][key]) el.innerText = translations[lang][key];
    });
    // Also re-render dynamic labels with new language
    refreshUserData();
  }
  document.addEventListener("DOMContentLoaded", function(){ updateLanguage(currentLang); });
</script>
</body>
</html>

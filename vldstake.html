<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>VLD Staking 1.0 + Unlock Date</title>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
<style>
  body {
    font-family: 'Roboto', sans-serif;
    background-color: #0b1120;
    color: #d0d0d0;
    margin: 0;
    padding: 2rem;
    text-align: center;
  }
  h1 { font-size: 2.2rem; margin-bottom: 1rem; }
  button {
    background-color: #3b82f6;
    color: white;
    border: none;
    padding: 0.75rem 1.5rem;
    margin: 0.5rem;
    border-radius: 8px;
    font-weight: bold;
    cursor: pointer;
  }
  input[type="number"] {
    padding: 0.5rem;
    font-size: 1rem;
    border-radius: 6px;
    border: 1px solid #334155;
    margin-right: 0.5rem;
    background:#0e1a33;
    color:#d0d0d0;
  }
  .section { margin-top: 2rem; }
  #account { margin-top: 1rem; font-style: italic; color: #94a3b8; word-break: break-all; }
  .note { color: #facc15; font-size: 0.95rem; margin-top: 0.5rem; }
  #warning { color: #f87171; font-size: 1rem; margin-top: 1rem; font-weight: bold; }
</style>
</head>
<body>
  <h1>VLD Staking 1.0 (step: Unlock)</h1>

  <button id="connect">üîó Connetti Wallet</button>
  <p id="account"></p>
  <p id="warning"></p>

  <div class="section">
    <h3>ü™ô Fai stake dei tuoi VLD</h3>
    <input id="amount" placeholder="Quantit√† VLD" type="number" step="any"/>
    <button id="stake">Stake</button>
    <p class="note" id="user-balance"></p>
    <p class="note" id="user-staked"></p>
  </div>

  <div class="section">
    <h3>üéÅ Claim reward</h3>
    <button id="claim">Claim</button>
  </div>

  <div class="section">
    <h3>üîì Unstake</h3>
    <button id="unstake" disabled>Unstake</button>
    <p class="note" id="unstake-info"></p>
  </div>

<script>
// === Indirizzi (aggiorna se necessari) ===
const contractAddress = "0x9AA246af0B01D51D5a9e59c1DdECa6544B8A0198"; // Staking
const tokenAddress    = "0xDF9387A2BF55F1e5b9f60599b6Ccbf6a5dA13A4b"; // VLD

// === ABI minime, solo ci√≤ che serve per questo step ===
const stakingAbi = [
  "function stake(uint256 amount)",
  "function claimReward()",
  "function unstake()",
  "function stakes(address) view returns (uint256 amount, uint256 startTime, uint256 lastClaim)",
  "function lockPeriod() view returns (uint256)"
];
const tokenAbi = [
  "function balanceOf(address) view returns (uint256)",
  "function allowance(address owner,address spender) view returns (uint256)",
  "function approve(address spender,uint256 amount) returns (bool)",
  "function decimals() view returns (uint8)",
  "function symbol() view returns (string)"
];

let provider, signer, staking, token, user, tokenDecimals = 18, symbol = "VLD";

function fmt(bn){ try { return ethers.utils.formatUnits(bn, tokenDecimals); } catch { return String(bn); } }

async function ensureBSC(){
  const net = await provider.getNetwork();
  if (net.chainId !== 56){
    try {
      await window.ethereum.request({ method: "wallet_switchEthereumChain", params: [{ chainId: "0x38" }] });
    } catch (e) {
      try {
        await window.ethereum.request({
          method: "wallet_addEthereumChain",
          params: [{
            chainId: "0x38",
            chainName: "BNB Smart Chain",
            nativeCurrency: { name: "BNB", symbol: "BNB", decimals: 18 },
            rpcUrls: ["https://bsc-dataseed.binance.org/"],
            blockExplorerUrls: ["https://bscscan.com/"]
          }]
        });
      } catch (addErr) {
        alert('Seleziona manualmente la rete "BNB Smart Chain" in MetaMask per continuare.');
      }
    }
  }
}

async function refresh(){
  if (!staking || !token || !user) return;

  try{
    const [bal, st, lp] = await Promise.all([
      token.balanceOf(user),
      staking.stakes(user),
      staking.lockPeriod()
    ]);

    // Tuple tolerant
    const amount    = st.amount ?? st[0] ?? ethers.constants.Zero;
    const startTime = st.startTime ?? st[1] ?? ethers.constants.Zero;

    document.getElementById("user-balance").innerText = "Saldo VLD: " + fmt(bal);
    document.getElementById("user-staked").innerText  = "In staking: " + fmt(amount) + " " + symbol;

    // === Aggiunta STEP: Data di unlock ===
    const unstakeBtn = document.getElementById("unstake");
    const ui = document.getElementById("unstake-info");

    if (ethers.BigNumber.from(amount).isZero()){
      ui.innerText = "Nessun importo in staking.";
      unstakeBtn.disabled = true;
    } else {
      // usiamo il timestamp del blocco per 'adesso'
      const block = await signer.provider.getBlock("latest");
      const now = block.timestamp;
      const unlockTime = Number(startTime) + Number(lp);
      if (now < unlockTime){
        ui.innerText = "Unstake disponibile dal: " + new Date(unlockTime * 1000).toLocaleString();
        unstakeBtn.disabled = true;
      } else {
        ui.innerText = "‚úÖ Puoi fare unstake ora.";
        unstakeBtn.disabled = false;
      }
    }
  }catch(e){
    console.error("refresh error", e);
  }
}

document.getElementById("connect").onclick = async () => {
  try{
    if (!window.ethereum) return alert("Installa MetaMask per continuare.");
    provider = new ethers.providers.Web3Provider(window.ethereum);
    await provider.send("eth_requestAccounts", []);
    await ensureBSC();
    signer = provider.getSigner();
    user = await signer.getAddress();
    document.getElementById("account").innerText = "Wallet: " + user;

    staking = new ethers.Contract(contractAddress, stakingAbi, signer);
    token   = new ethers.Contract(tokenAddress, tokenAbi, signer);
    try { tokenDecimals = await token.decimals(); } catch { tokenDecimals = 18; }
    try { symbol = await token.symbol(); } catch { symbol = "VLD"; }

    await refresh();
    // auto refresh leggero
    setInterval(refresh, 20000);
  }catch(e){
    console.error(e);
    alert("Errore nella connessione al wallet.");
  }
};

document.getElementById("stake").onclick = async () => {
  try{
    const v = (document.getElementById("amount").value || "").trim();
    if (!v) return alert("Inserisci un importo valido.");
    const amount = ethers.utils.parseUnits(v, tokenDecimals);

    // approve se necessario
    const allowance = await token.allowance(user, contractAddress);
    if (allowance.lt(amount)){
      const txA = await token.approve(contractAddress, ethers.constants.MaxUint256);
      await txA.wait();
    }

    let gas; try{ gas = await staking.estimateGas.stake(amount); } catch{}
    const tx = await staking.stake(amount, gas ? { gasLimit: gas.mul(115).div(100) } : {});
    await tx.wait();
    alert("Stake eseguito!");
    document.getElementById("amount").value = "";
    await refresh();
  }catch(e){ console.error(e); alert("Errore durante lo stake."); }
};

document.getElementById("claim").onclick = async () => {
  try{
    let gas; try{ gas = await staking.estimateGas.claimReward(); } catch{}
    const tx = await staking.claimReward(gas ? { gasLimit: gas.mul(115).div(100) } : {});
    await tx.wait();
    alert("Reward ricevuta!");
    await refresh();
  }catch(e){ console.error(e); alert("Errore durante il claim."); }
};

document.getElementById("unstake").onclick = async () => {
  try{
    let gas; try{ gas = await staking.estimateGas.unstake(); } catch{}
    const tx = await staking.unstake(gas ? { gasLimit: gas.mul(115).div(100) } : {});
    await tx.wait();
    alert("Unstake completato!");
    await refresh();
  }catch(e){ console.error(e); alert("Errore durante l'unstake."); }
};
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>VLD Staking</title>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
<style>
  body {
    font-family: 'Roboto', sans-serif;
    background-color: #0b1120;
    color: #d0d0d0;
    margin: 0;
    padding: 2rem;
    text-align: center;
  }
  h1 {
    font-size: 2.5rem;
    margin-bottom: 1rem;
  }
  button {
    background-color: #3b82f6;
    color: white;
    border: none;
    padding: 0.75rem 1.5rem;
    margin: 0.5rem;
    border-radius: 8px;
    font-weight: bold;
    cursor: pointer;
  }
  input[type="number"] {
    padding: 0.5rem;
    font-size: 1rem;
    border-radius: 6px;
    border: 1px solid #ccc;
    margin-right: 0.5rem;
    background:#0e1a33;
    color:#d0d0d0;
  }
  .section { margin-top: 2rem; }
  #account {
    margin-top: 1rem;
    font-style: italic;
    color: #94a3b8;
    word-break: break-all;
  }
  .note { color: #facc15; font-size: 0.95rem; margin-top: 0.5rem; }
  #warning { color: #f87171; font-size: 1rem; margin-top: 1rem; font-weight: bold; }
  .langbar{position: absolute; top: 1rem; right: 1rem; display: flex; gap: 0.5rem; align-items: center;}
  .langbar button{padding:0.4rem 0.8rem;border-radius:6px}
</style>
</head>
<body>
  <div class="langbar">
    üåê
    <button data-i18n="lang_ita" onclick="updateLanguage('it')">ITA</button>
    <button data-i18n="lang_eng" onclick="updateLanguage('en')">ENG</button>
  </div>

  <h1 data-i18n="title">VLD Staking Interface 1.05</h1>

  <button data-i18n="connect" id="connect">üîó Connetti Wallet</button>
  <p id="account"></p>
  <p id="warning"></p>

  <div class="section">
    <h3 data-i18n="stake_title">ü™ô Fai stake dei tuoi VLD</h3>
    <input id="amount" placeholder="Quantit√† VLD" type="number"/>
    <button data-i18n="stake_button" id="stake">Stake</button>
    <p class="note" data-i18n="stake_note">‚è≥ Periodo minimo di blocco: 30 giorni</p>
    <p class="note" id="user-balance"></p>
    <p class="note" id="user-staked"></p>
  </div>

  <div class="section">
    <h3 data-i18n="claim_title">üéÅ Claim reward</h3>
    <button data-i18n="claim_button" id="claim">Claim</button>
    <p class="note" id="estimated-reward"></p>
  </div>

  <div class="section">
    <h3 data-i18n="unstake_title">üîì Unstake</h3>
    <button data-i18n="unstake_button" id="unstake" disabled>Unstake</button>
    <p class="note" id="unstake-info"></p>
  </div>

<script>
  // ===== Addresses =====
  const contractAddress = "0x9AA246af0B01D51D5a9e59c1DdECa6544B8A0198"; // Staking
  const tokenAddress    = "0xDF9387A2BF55F1e5b9f60599b6Ccbf6a5dA13A4b"; // VLD

  // ===== ABIs (aligned to contract) =====
  const abi = [
    "function stake(uint256 amount) public",
    "function claimReward() public",
    "function unstake() public",
    "function stakes(address) view returns (uint256 amount, uint256 startTime, uint256 lastClaim)",
    "function totalStaked() view returns (uint256)",
    "function lockPeriod() view returns (uint256)",
    "function aprBasisPoints() view returns (uint256)",
    "function getPendingReward(address) view returns (uint256)"
  ];

  const tokenAbi = [
    "function approve(address spender, uint256 amount) public returns (bool)",
    "function balanceOf(address account) view returns (uint256)",
    "function allowance(address owner, address spender) view returns (uint256)",
    "function decimals() view returns (uint8)",
    "function symbol() view returns (string)"
  ];

  let signer, userAddress, stakingContract, tokenContract, tokenDecimals = 18, tokenSymbol="VLD";

  // ===== Network helper =====
  async function ensureBSC(provider) {
    const network = await provider.getNetwork();
    if (network.chainId === 56) return;
    try {
      await window.ethereum.request({
        method: 'wallet_switchEthereumChain',
        params: [{ chainId: '0x38' }]
      });
    } catch (switchErr) {
      if (switchErr.code === 4902) {
        try {
          await window.ethereum.request({
            method: 'wallet_addEthereumChain',
            params: [{
              chainId: '0x38', // 56
              chainName: 'BNB Smart Chain',
              nativeCurrency: { name: 'BNB', symbol: 'BNB', decimals: 18 },
              rpcUrls: ['https://bsc-dataseed.binance.org/'],
              blockExplorerUrls: ['https://bscscan.com/']
            }]
          });
        } catch (e) {
          alert('Seleziona manualmente la rete "BNB Smart Chain" in MetaMask per continuare.');
        }
      } else {
        alert('Seleziona manualmente la rete "BNB Smart Chain" in MetaMask per continuare.');
      }
    }
  }

  // ===== UI Refresh =====
  async function refreshUserData() {
    if (!stakingContract || !tokenContract || !userAddress) return;
    try {
      // Saldo & Staked
      const [userBalance, stakeInfo] = await Promise.all([
        tokenContract.balanceOf(userAddress),
        stakingContract.stakes(userAddress)
      ]);
      document.getElementById("user-balance").innerText =
        `${translations[currentLang].balance_label || "Saldo VLD"}: ${ethers.utils.formatUnits(userBalance, tokenDecimals)} ${tokenSymbol}`;

      document.getElementById("user-staked").innerText =
        `${translations[currentLang].staked_label || "In staking"}: ${ethers.utils.formatUnits(stakeInfo.amount, tokenDecimals)} ${tokenSymbol}`;

      // Lock period + APR
      const [lp, bp] = await Promise.all([
        stakingContract.lockPeriod(),
        stakingContract.aprBasisPoints()
      ]);
      const days = Math.floor(lp.toNumber()/86400);
      const aprPercent = (Number(bp.toString())/100).toFixed(2);
      const stakeNoteEl = document.querySelector('[data-i18n="stake_note"]');
      if (stakeNoteEl) {
        if (currentLang === "en") {
          stakeNoteEl.innerText = `‚è≥ Minimum lock period: ${days} days ‚Äî APR: ${aprPercent}%`;
        } else {
          stakeNoteEl.innerText = `‚è≥ Periodo minimo di blocco: ${days} giorni ‚Äî APR: ${aprPercent}%`;
        }
      }

      // Reward maturata (on-chain)
      const pending = await stakingContract.getPendingReward(userAddress);
      const rewardOutput = document.getElementById("estimated-reward");
      if (!pending.isZero()) {
        rewardOutput.innerText = `${translations[currentLang].reward_ready} ${ethers.utils.formatUnits(pending, tokenDecimals)} ${tokenSymbol}`;
      } else {
        rewardOutput.innerText = translations[currentLang].reward_none;
      }

      // Unstake gating + data
      const unstakeButton = document.getElementById("unstake");
      const unstakeInfo   = document.getElementById("unstake-info");
      const currentBlock = await signer.provider.getBlock("latest");
      const now = currentBlock.timestamp;
      const stakeStart  = stakeInfo.startTime.toNumber();
      const unlockTime  = stakeStart + lp.toNumber();

      if (stakeInfo.amount.isZero()) {
        unstakeInfo.innerText = "";
        unstakeButton.disabled = true;
      } else if (now < unlockTime) {
        const unlockDate = new Date(unlockTime * 1000);
        if (currentLang === "en") {
          unstakeInfo.innerText = `${translations[currentLang].unstake_locked} ${unlockDate.toLocaleString()}`;
        } else {
          unstakeInfo.innerText = `${translations[currentLang].unstake_locked} ${unlockDate.toLocaleString()}`;
        }
        unstakeButton.disabled = true;
      } else {
        unstakeInfo.innerText = translations[currentLang].unstake_now;
        unstakeButton.disabled = false;
      }

      // Avviso fondi reward (stima reserve = contractBal - TVL; se <= 0, warning)
      const [contractBal, tvl] = await Promise.all([
        tokenContract.balanceOf(contractAddress),
        stakingContract.totalStaked()
      ]);
      let hasReserve = false;
      if (contractBal.gt(tvl)) { hasReserve = true; }
      document.getElementById("warning").innerText = hasReserve ? "" : translations[currentLang].contract_warning;

    } catch (err) {
      console.error("Errore in refreshUserData:", err);
    }
  }

  // ===== Connect =====
  document.getElementById("connect").onclick = async () => {
    try {
      if (!window.ethereum) return alert(translations[currentLang].install_metamask);

      const provider = new ethers.providers.Web3Provider(window.ethereum);
      await provider.send("eth_requestAccounts", []);
      await ensureBSC(provider);

      signer = provider.getSigner();
      userAddress = await signer.getAddress();
      document.getElementById("account").innerText = `${translations[currentLang].wallet_connected}${userAddress}`;

      stakingContract = new ethers.Contract(contractAddress, abi, signer);
      tokenContract   = new ethers.Contract(tokenAddress, tokenAbi, signer);

      try { tokenDecimals = await tokenContract.decimals(); } catch { tokenDecimals = 18; }
      try { tokenSymbol = await tokenContract.symbol(); } catch { tokenSymbol = "VLD"; }

      await refreshUserData();
      // Auto refresh
      setInterval(refreshUserData, 20000);
    } catch (error) {
      console.error("Errore nella connessione wallet:", error);
      alert(translations[currentLang].error_wallet);
    }
  };

  // ===== Actions (NO estimateGas, faithful to 1.0) =====
  document.getElementById("stake").onclick = async () => {
    if (!stakingContract || !tokenContract) return alert(translations[currentLang].connect_first);

    const amountStr = (document.getElementById("amount").value || "").trim();
    if (!amountStr || isNaN(amountStr)) return alert(translations[currentLang].invalid_amount);

    const amountParsed = ethers.utils.parseUnits(amountStr.replace(",", "."), tokenDecimals);
    const walletBalance  = await tokenContract.balanceOf(userAddress);
    if (walletBalance.lt(amountParsed)) return alert(translations[currentLang].insufficient_balance);

    try {
      // Approve MaxUint256 se necessario
      const currentAllowance = await tokenContract.allowance(userAddress, contractAddress);
      if (currentAllowance.lt(amountParsed)) {
        const max = ethers.constants.MaxUint256;
        const approveTx = await tokenContract.approve(contractAddress, max);
        await approveTx.wait();
        // micro delay per stabilizzare RPC
        await new Promise(r => setTimeout(r, 500));
      }

      const stakeTx = await stakingContract.stake(amountParsed); // niente estimateGas
      await stakeTx.wait();
      alert(translations[currentLang].success_stake);
      await refreshUserData();
    } catch (e) {
      console.error("Errore durante lo stake:", e);
      alert(translations[currentLang].error_stake);
    }
  };

  document.getElementById("claim").onclick = async () => {
    if (!stakingContract) return alert(translations[currentLang].connect_first);
    try {
      const tx = await stakingContract.claimReward(); // niente estimateGas
      await tx.wait();
      alert(translations[currentLang].success_claim);
      await refreshUserData();
    } catch (e) {
      console.error("Errore durante il claim:", e);
      alert(translations[currentLang].error_claim);
    }
  };

  document.getElementById("unstake").onclick = async () => {
    if (!stakingContract) return alert(translations[currentLang].connect_first);
    try {
      const tx = await stakingContract.unstake(); // niente estimateGas
      await tx.wait();
      alert(translations[currentLang].success_unstake);
      await refreshUserData();
    } catch (e) {
      console.error("Errore durante l'unstake:", e);
      alert(translations[currentLang].error_unstake);
    }
  };
</script>

<script>
// ===== i18n =====
const translations = {
  it: {
    lang_ita: "ITA",
    lang_eng: "ENG",
    unstake_button: "Unstake",
    install_metamask: "Installa Metamask!",

    title: "Interfaccia VLD Staking 1.05",
    connect: "üîó Connetti Wallet",
    stake_title: "ü™ô Fai stake dei tuoi VLD",
    stake_note: "‚è≥ Periodo minimo di blocco: 30 giorni",
    stake_button: "Stake",
    unstake_title: "üîì Unstake",
    unstake_now: "‚úÖ Puoi fare unstake ora.",
    unstake_locked: "üîí Unstake disponibile dal:",
    claim_title: "üéÅ Claim reward",
    claim_button: "Claim",
    reward_ready: "üéØ Reward maturata:",
    reward_none: "üéØ Nessuna reward maturata al momento.",
    contract_warning: "‚ö†Ô∏è Il contratto non ha token VLD per i reward. Lo staking fallir√† finch√© non verr√† finanziato.",
    wallet_connected: "Wallet: ",
    balance_label: "Saldo VLD",
    staked_label: "In staking",
    error_wallet: "Errore nella connessione al wallet.",
    error_claim: "Errore durante il claim",
    success_claim: "Reward ricevuto!",
    error_unstake: "Errore durante l'unstake",
    success_unstake: "Unstake completato!",
    error_stake: "Errore durante lo stake",
    success_stake: "Stake eseguito!",
    invalid_amount: "Inserisci un importo valido",
    insufficient_balance: "Saldo insufficiente per fare stake!",
    connect_first: "Devi prima connettere il wallet!"
  },
  en: {
    lang_ita: "ITA",
    lang_eng: "ENG",
    unstake_button: "Unstake",
    install_metamask: "Install Metamask!",

    title: "VLD Staking Interface 1.05",
    connect: "üîó Connect Wallet",
    stake_title: "ü™ô Stake your VLD",
    stake_note: "‚è≥ Minimum lock period: 30 days",
    stake_button: "Stake",
    unstake_title: "üîì Unstake",
    unstake_now: "‚úÖ You can unstake now.",
    unstake_locked: "üîí Unstake available from:",
    claim_title: "üéÅ Claim reward",
    claim_button: "Claim",
    reward_ready: "üéØ Reward accrued:",
    reward_none: "üéØ No reward accrued yet.",
    contract_warning: "‚ö†Ô∏è Contract has no VLD tokens for rewards. Staking will fail until it is funded.",
    wallet_connected: "Wallet: ",
    balance_label: "VLD Balance",
    staked_label: "Staked",
    error_wallet: "Error connecting wallet.",
    error_claim: "Error during claim",
    success_claim: "Reward claimed!",
    error_unstake: "Error during unstake",
    success_unstake: "Unstake completed!",
    error_stake: "Error during stake",
    success_stake: "Stake successful!",
    invalid_amount: "Please enter a valid amount",
    insufficient_balance: "Insufficient balance to stake!",
    connect_first: "You must connect your wallet first!"
  }
};

let currentLang = "it";

function updateLanguage(lang) {
  currentLang = lang;
  document.querySelectorAll("[data-i18n]").forEach(el => {
    const key = el.getAttribute("data-i18n");
    if (translations[lang][key]) el.innerText = translations[lang][key];
  });
  // Recompute dynamic texts in the new language
  if (typeof refreshUserData === 'function') refreshUserData();
}

document.addEventListener("DOMContentLoaded", function () {
  updateLanguage(currentLang);
});
</script>
</body>
</html>

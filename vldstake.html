<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>VLD Staking 1.05-fix</title>
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
</head>
<body style="background:#0b1120;color:#d0d0d0;font-family:sans-serif;text-align:center;padding:2rem">

<h1>VLD Staking 1.0</h1>

<button id="connect">ðŸ”— Connetti Wallet</button>
<p id="account"></p>
<p id="user-balance"></p>
<p id="user-staked"></p>
<p id="unstake-info"></p>
<p id="pending-reward"></p>

<input id="amount" type="number" placeholder="QuantitÃ  VLD" step="any"/>
<button id="stake">Stake</button>
<button id="claim">Claim</button>
<button id="unstake" disabled>Unstake</button>

<script>
const contractAddress = "0x9AA246af0B01D51D5a9e59c1DdECa6544B8A0198"; // staking
const tokenAddress    = "0xDF9387A2BF55F1e5b9f60599b6Ccbf6a5dA13A4b"; // VLD

const abi = [
  "function stake(uint256 amount)",
  "function claimReward()",
  "function unstake()",
  "function stakes(address) view returns (uint256 amount, uint256 startTime, uint256 lastClaim)",
  "function totalStaked() view returns (uint256)",
  "function lockPeriod() view returns (uint256)",
  "function aprBasisPoints() view returns (uint256)",
  "function getPendingReward(address) view returns (uint256)"
];
const tokenAbi = [
  "function balanceOf(address) view returns (uint256)",
  "function allowance(address owner,address spender) view returns (uint256)",
  "function approve(address spender,uint256 amount) returns (bool)",
  "function decimals() view returns (uint8)",
  "function symbol() view returns (string)"
];

let provider, signer, staking, token, userAddress, tokenDecimals=18, symbol="VLD";

function fmt(bn){ return ethers.utils.formatUnits(bn, tokenDecimals); }

async function refresh(){
  if(!staking||!token||!userAddress) return;

  const [bal, st, lp, pending] = await Promise.all([
    token.balanceOf(userAddress),
    staking.stakes(userAddress),
    staking.lockPeriod(),
    staking.getPendingReward(userAddress)
  ]);

  const amount    = st.amount ?? st[0];
  const startTime = st.startTime ?? st[1];
  const lastClaim = st.lastClaim ?? st[2];

  document.getElementById("user-balance").innerText = `Saldo wallet: ${fmt(bal)} ${symbol}`;
  document.getElementById("user-staked").innerText  = `In staking: ${fmt(amount)} ${symbol}`;
  document.getElementById("pending-reward").innerText = `Reward maturata: ${fmt(pending)} ${symbol}`;

  const now = Math.floor(Date.now()/1000);
  const unlockTime = Number(startTime) + Number(lp);
  const unstakeBtn = document.getElementById("unstake");

  if(amount == 0){
    document.getElementById("unstake-info").innerText = "Nessun importo in staking.";
    unstakeBtn.disabled = true;
  } else if(now < unlockTime){
    document.getElementById("unstake-info").innerText = "Unstake disponibile dal: " + new Date(unlockTime*1000).toLocaleString();
    unstakeBtn.disabled = true;
  } else {
    document.getElementById("unstake-info").innerText = "âœ… Puoi fare unstake ora.";
    unstakeBtn.disabled = false;
  }
}

document.getElementById("connect").onclick = async () => {
  provider = new ethers.providers.Web3Provider(window.ethereum);
  await provider.send("eth_requestAccounts", []);
  signer = provider.getSigner();
  userAddress = await signer.getAddress();
  document.getElementById("account").innerText = "Wallet: " + userAddress;

  staking = new ethers.Contract(contractAddress, abi, signer);
  token   = new ethers.Contract(tokenAddress, tokenAbi, signer);
  tokenDecimals = await token.decimals();
  symbol = await token.symbol();

  refresh();
  setInterval(refresh, 20000);
};

// Stake
document.getElementById("stake").onclick = async ()=>{
  const val = document.getElementById("amount").value;
  if(!val) return alert("Inserisci un importo");
  const amount = ethers.utils.parseUnits(val, tokenDecimals);
  const allowance = await token.allowance(userAddress, contractAddress);
  if(allowance.lt(amount)){
    const txA = await token.approve(contractAddress, ethers.constants.MaxUint256);
    await txA.wait();
  }
  const tx = await staking.stake(amount); await tx.wait();
  alert("Stake eseguito!"); refresh();
};
// Claim
document.getElementById("claim").onclick = async ()=>{
  const tx = await staking.claimReward(); await tx.wait();
  alert("Reward ricevuta!"); refresh();
};
// Unstake
document.getElementById("unstake").onclick = async ()=>{
  const tx = await staking.unstake(); await tx.wait();
  alert("Unstake completato!"); refresh();
};
</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Validora • NFT File Certification 1.1 (BSC Testnet)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.11.1/dist/ethers.umd.min.js"></script>
  <style>
    :root{--bg:#0b1120;--card:#111827;--muted:#94a3b8;--accent:#22d3ee;--ok:#22c55e;--warn:#f59e0b;--err:#ef4444}
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,#0b1120,#0f172a);color:#e2e8f0}
    .wrap{max-width:980px;margin:24px auto;padding:16px}
    h1{font-size:28px;margin:0 0 12px 0}
    .card{background:var(--card);border:1px solid #1f2937;border-radius:16px;padding:18px;box-shadow:0 6px 24px rgba(0,0,0,.25)}
    .row{display:flex;flex-wrap:wrap;gap:12px;align-items:center}
    .col{flex:1 1 240px}
    label{font-size:12px;letter-spacing:.02em;color:var(--muted)}
    input,button,select{width:100%;padding:12px;border-radius:12px;border:1px solid #334155;background:#0b1220;color:#e2e8f0;outline:none}
    input:focus,select:focus{border-color:#38bdf8;box-shadow:0 0 0 3px rgba(56,189,248,.2)}
    button{cursor:pointer;background:#0ea5e9;border-color:#0ea5e9;font-weight:600}
    button.secondary{background:#1f2937;border-color:#334155}
    button.ok{background:var(--ok);border-color:var(--ok)}
    button.warn{background:var(--warn);border-color:var(--warn)}
    button.ghost{background:transparent;border-color:#334155}
    button:disabled{opacity:.6;cursor:not-allowed}
    .split{display:grid;grid-template-columns:1.2fr .8fr;gap:16px}
    .muted{color:var(--muted)}
    .pill{display:inline-block;padding:4px 8px;border-radius:999px;background:#0b1220;border:1px solid #334155;color:#cbd5e1;font-size:12px}
    .hr{height:1px;background:#1f2937;margin:16px 0}
    .grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:12px}
    .topbar{display:flex;gap:12px;align-items:flex-start;justify-content:space-between;margin-bottom:8px}
    .conn{display:flex;gap:8px;align-items:center}
    .status{margin-top:8px;font-size:12px;color:#cbd5e1}
    .status code{color:#e2e8f0}
    .footer-log{margin-top:16px}
    .log{font-family:ui-monospace, Menlo, Consolas, "Courier New", monospace;height:220px;overflow:auto;background:#0a0f1e;border-radius:12px;border:1px solid #1f2a3a;padding:12px}
    @media (max-width:900px){.split{grid-template-columns:1fr}.grid{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div>
        <h1 data-i18n="title">Validora • NFT File Certification <span class="pill">BSC Testnet</span></h1>
        <div class="muted" style="margin-top:4px">
          <label for="lang" class="muted" data-i18n="language">Language</label>
          <select id="lang" style="width:auto;display:inline-block;margin-left:8px">
            <option value="en">English</option>
            <option value="it">Italiano</option>
          </select>
        </div>
      </div>
      <div>
        <div class="conn">
          <button id="btnConnect" class="ok" data-i18n="btnConnect">Connect wallet</button>
          <button id="btnDisconnect" class="ghost" data-i18n="btnDisconnect">Disconnect</button>
        </div>
        <div class="status">
          <div><span data-i18n="statusWallet">Wallet:</span> <code id="statusAddr">—</code></div>
          <div><span data-i18n="statusNetwork">Network:</span> <code id="statusNet">—</code></div>
        </div>
      </div>
    </div>

    <div class="card">
      <!-- Hidden, hard-coded addresses (non editable) -->
      <input id="contract" type="hidden" value="0xf5539442a2E1585365d8Fdb905A745b56D7aD020"/>
      <input id="vld" type="hidden" value="0xD6B7DA76B70875f0959aFb20467cD991D89Cf89b"/>

      <div class="grid">
        <div>
          <label data-i18n="mode">Mode</label>
          <select id="mode">
            <option value="single" data-i18n="single">Single file</option>
            <option value="batch" data-i18n="batch">Batch (multi file)</option>
          </select>
        </div>
      </div>

      <div class="hr"></div>

      <div class="grid">
        <div id="singleWrap">
          <label data-i18n="selectFile">Select file</label>
          <input id="file" type="file"/>
        </div>
        <div id="multiWrap" style="display:none">
          <label data-i18n="selectFiles">Select multiple files</label>
          <input id="files" type="file" multiple/>
        </div>
      </div>

      <div class="grid" style="margin-top:12px">
        <div>
          <label data-i18n="previewLabel">Metadata preview (inline)</label>
          <button id="preview" class="secondary" data-i18n="preview">Generate preview</button>
        </div>
        <div>
          <label data-i18n="feeLabel">Estimated fee</label>
          <input id="fee" readonly placeholder="0 VLD"/>
        </div>
      </div>

      <div class="grid" style="margin-top:12px">
        <button id="approve" class="warn" data-i18n="approve">1) Approve VLD</button>
        <button id="mint" class="ok" data-i18n="mint">2) Certify / Mint</button>
      </div>

      <p class="muted" style="margin-top:12px" data-i18n="hint">Tip: in <b>Batch</b> mode each file gets a deterministic SVG identicon and its own JSON metadata, sent to <code>certifyBatch(hashes, sizes, uris)</code>.</p>
      <p class="muted" data-i18n="privacy">This tool uploads nothing to servers: everything runs locally in your browser and on‑chain.</p>
    </div>

    <!-- FOOTER LOG -->
    <div class="footer-log">
      <label data-i18n="log">Log</label>
      <div id="log" class="log"></div>
    </div>
  </div>

<script>
const $ = (id) => document.getElementById(id);
const log = (m, cls="") => { const d=document.createElement('div'); d.innerHTML = m; if(cls) d.style.color=cls; $('log').appendChild(d); $('log').scrollTop = $('log').scrollHeight; };

// UTF‑8 safe base64 encoder (works in browsers)
function b64utf8(str){
  const bytes = new TextEncoder().encode(str);
  let binary = '';
  const chunk = 0x8000; // avoid call stack overflow
  for(let i=0; i<bytes.length; i+=chunk){
    binary += String.fromCharCode.apply(null, bytes.subarray(i, i+chunk));
  }
  return btoa(binary);
}

// ===== Addresses (hard-coded, hidden) =====
const CONTRACT_ADDR = $('contract').value; // FileCertifierNFT
const VLD_ADDR      = $('vld').value;      // VLD token

// ===== I18N =====
const I18N = {
  en: {
    title: "Validora • NFT File Certification <span class=\"pill\">BSC Testnet</span>",
    language: "Language",
    btnConnect: "Connect wallet",
    btnDisconnect: "Disconnect",
    statusWallet: "Wallet:",
    statusNetwork: "Network:",
    mode: "Mode",
    single: "Single file",
    batch: "Batch (multi file)",
    connect: "Connect & switch to BSC Testnet",
    selectFile: "Select file",
    selectFiles: "Select multiple files",
    previewLabel: "Metadata preview (inline)",
    preview: "Generate preview",
    feeLabel: "Estimated fee",
    approve: "1) Approve VLD",
    mint: "2) Certify / Mint",
    log: "Log",
    hint: "Tip: in <b>Batch</b> mode each file gets a deterministic SVG identicon and its own JSON metadata, sent to <code>certifyBatch(hashes, sizes, uris)</code>.",
    privacy: "This tool uploads nothing to servers: everything runs locally in your browser and on‑chain.",
    needWallet: "A compatible wallet is required (e.g. MetaMask).",
    connectFirst: "Connect your wallet and switch network.",
    selectAFile: "Please choose a file.",
    selectFilesFirst: "Choose at least 2 files.",
    feeEstimated: (v) => `Estimated fee: ${v} VLD`,
    walletConnected: (a) => `Wallet connected: ${a}`,
    chainSwitchError: (m) => `Network switch error: ${m}`,
    approveProgress: "Approving VLD…",
    approveOk: (h) => `✔ Approve confirmed: ${h}`,
    previewHash: (h) => `Hash: ${h}`,
    previewUri: (u) => `URI preview (begin): ${u}`,
    mintSingle: "Minting single…",
    mintBatch: (n) => `Minting batch of ${n}…`,
    mintOk: (h) => `✔ Mint OK: ${h}`,
  },
  it: {
    title: "Validora • Certificazione File via NFT <span class=\"pill\">BSC Testnet</span>",
    language: "Lingua",
    btnConnect: "Connetti wallet",
    btnDisconnect: "Disconnetti",
    statusWallet: "Wallet:",
    statusNetwork: "Rete:",
    mode: "Modalità",
    single: "Singolo file",
    batch: "Batch (multi file)",
    connect: "Connetti & passa a BSC Testnet",
    selectFile: "Seleziona file",
    selectFiles: "Seleziona più file",
    previewLabel: "Anteprima metadata (inline)",
    preview: "Genera anteprima",
    feeLabel: "Fee stimata",
    approve: "1) Approva VLD",
    mint: "2) Certify / Mint",
    log: "Log",
    hint: "Suggerimento: in modalità <b>Batch</b> ogni file genera un identicon SVG deterministico e un proprio JSON, inviato a <code>certifyBatch(hashes, sizes, uris)</code>.",
    privacy: "Questo tool non carica nulla su server: tutto avviene localmente nel browser e on‑chain.",
    needWallet: "Serve un wallet compatibile (es. MetaMask).",
    connectFirst: "Connetti il wallet e cambia rete.",
    selectAFile: "Seleziona un file.",
    selectFilesFirst: "Seleziona almeno due file.",
    feeEstimated: (v) => `Fee stimata: ${v} VLD`,
    walletConnected: (a) => `Wallet connesso: ${a}`,
    chainSwitchError: (m) => `Errore cambio rete: ${m}`,
    approveProgress: "Approvazione VLD in corso…",
    approveOk: (h) => `✔ Approve confermata: ${h}`,
    previewHash: (h) => `Hash: ${h}`,
    previewUri: (u) => `Anteprima URI (inizio): ${u}`,
    mintSingle: "Mint singolo…",
    mintBatch: (n) => `Mint batch di ${n}…`,
    mintOk: (h) => `✔ Mint OK: ${h}`,
  }
};

function applyLang(lang){
  document.documentElement.lang = lang === 'it' ? 'it' : 'en';
  const dict = I18N[lang];
  document.querySelectorAll('[data-i18n]').forEach(el=>{
    const key = el.getAttribute('data-i18n');
    const val = dict[key];
    if(typeof val === 'string') el.innerHTML = val;
  });
  $('mode').querySelector('option[value="single"]').textContent = dict.single;
  $('mode').querySelector('option[value="batch"]').textContent  = dict.batch;
}
$('lang').addEventListener('change', e => applyLang(e.target.value));
applyLang('en');

// ===== Chain / wallet =====
const CHAIN_ID_HEX = '0x61'; // BSC Testnet
let provider, signer, account;

function shortAddr(a){ return a ? a.slice(0,6) + '…' + a.slice(-4) : '—'; }
function updateStatus(net){
  $('statusAddr').textContent = account ? shortAddr(account) : '—';
  $('statusNet').textContent  = net ? `${net.name||'unknown'} (${net.chainId})` : '—';
}

async function connectWallet(){
  const L = I18N[document.documentElement.lang];
  if(!window.ethereum){ alert(L.needWallet); return; }
  try{
    await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: CHAIN_ID_HEX }] });
  }catch(err){
    if(err.code === 4902){
      await window.ethereum.request({
        method:'wallet_addEthereumChain',
        params:[{ chainId: CHAIN_ID_HEX, chainName:'BSC Testnet', nativeCurrency:{name:'tBNB',symbol:'tBNB',decimals:18}, rpcUrls:['https://data-seed-prebsc-1-s1.binance.org:8545/'], blockExplorerUrls:['https://testnet.bscscan.com'] }]
      });
    } else {
      log(I18N[document.documentElement.lang].chainSwitchError(err.message), '#ef4444');
      return;
    }
  }
  provider = new ethers.BrowserProvider(window.ethereum);
  signer   = await provider.getSigner();
  account  = await signer.getAddress();
  const net = await provider.getNetwork();
  updateStatus(net);
  log(I18N[document.documentElement.lang].walletConnected(account));
}

function disconnectWallet(){
  provider = undefined; signer = undefined; account = undefined;
  updateStatus(null);
  log('Disconnected');
}

// react to wallet changes
if(window.ethereum){
  window.ethereum.on?.('accountsChanged', async (accs)=>{
    account = accs && accs[0] ? accs[0] : undefined;
    const net = provider ? await provider.getNetwork() : null;
    updateStatus(net);
  });
  window.ethereum.on?.('chainChanged', async ()=>{
    const net = provider ? await provider.getNetwork() : null;
    updateStatus(net);
  });
}

$('btnConnect').addEventListener('click', connectWallet);
$('btnDisconnect').addEventListener('click', disconnectWallet);

$('mode').addEventListener('change', (e)=>{
  const batch = e.target.value === 'batch';
  $('multiWrap').style.display = batch ? 'block' : 'none';
  $('singleWrap').style.display = batch ? 'none' : 'block';
});

function identiconSVG(hash, size=600){
  const seed = hash.slice(2);
  const color = '#' + seed.slice(0,6);
  const cells=5, cell=size/cells; let rects='';
  for(let y=0;y<cells;y++){
    for(let x=0;x<Math.ceil(cells/2);x++){
      const idx = (y*cells + x) % (seed.length/2);
      const on = (parseInt(seed.slice(idx*2, idx*2+2),16) & 1)===0;
      if(on){
        const rx = x*cell, lx=(cells-1-x)*cell, ypx=y*cell;
        rects += `<rect x='${rx}' y='${ypx}' width='${cell}' height='${cell}' fill='${color}'/>`;
        if(lx!==rx) rects += `<rect x='${lx}' y='${ypx}' width='${cell}' height='${cell}' fill='${color}'/>`;
      }
    }
  }
  const svg = `<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 ${size} ${size}' width='${size}' height='${size}'>${rects}</svg>`;
  return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
}

function buildMetaURIWithFallback(hash, size){
  try{
    const meta = {
      name: `Validora Certification — ${hash.slice(0,10)}…`,
      description: `On-chain proof of authenticity.\nHash: ${hash}\nAlgorithm: keccak256`,
      image: identiconSVG(hash, 240),
      attributes: [
        { trait_type: 'Hash (keccak256)', value: hash },
        { trait_type: 'File Size (bytes)', display_type: 'number', value: Number(size) }
      ]
    };
    let uri  = 'data:application/json;base64,' + b64utf8(JSON.stringify(meta));
    if (uri.length > 2000) {
      const compact = {
        name: `Validora — ${hash.slice(0,10)}…`,
        image: identiconSVG(hash, 200),
        attributes: [
          { trait_type: 'Hash (keccak256)', value: hash },
          { trait_type: 'File Size (bytes)', display_type: 'number', value: Number(size) }
        ]
      };
      uri = 'data:application/json;base64,' + b64utf8(JSON.stringify(compact));
    }
    return uri;
  }catch(e){
    console.error('buildMetaURIWithFallback error', e);
    const minimal = { name: `Validora — ${hash.slice(0,10)}…`, image: identiconSVG(hash, 160) };
    return 'data:application/json;base64,' + b64utf8(JSON.stringify(minimal));
  }
}

function needConnection(){ return !(provider && signer && account); }

$('preview').addEventListener('click', async ()=>{
  const L = I18N[document.documentElement.lang];
  try{
    if(needConnection()) return log(L.connectFirst, '#f59e0b');
    const mode = $('mode').value;
    if(mode==='single'){
      const f = $('file').files[0]; if(!f) return alert(L.selectAFile);
      const bytes = new Uint8Array(await f.arrayBuffer());
      const hash = ethers.keccak256(bytes);
      const size = BigInt(bytes.length);
      const uri  = buildMetaURIWithFallback(hash, size);
      log(L.previewHash(hash));
      log(L.previewUri(uri.slice(0,80) + '…'));
      const cert = new ethers.Contract(CONTRACT_ADDR, [ 'function quoteItem(uint64) view returns (uint256)' ], provider);
      const fee  = await cert.quoteItem(size);
      const v = ethers.formatUnits(fee, 18);
      $('fee').value = v + ' VLD';
      log(L.feeEstimated(v));
    } else {
      const list = $('files').files; if(!list.length) return alert(L.selectFilesFirst);
      const sizes=[], hashes=[], uris=[];
      for(const f of list){
        const bytes = new Uint8Array(await f.arrayBuffer());
        const hash = ethers.keccak256(bytes);
        const size = BigInt(bytes.length);
        hashes.push(hash); sizes.push(size);
        uris.push(buildMetaURIWithFallback(hash, size));
      }
      const cert = new ethers.Contract(CONTRACT_ADDR, [ 'function quoteBatch(uint64[]) view returns (uint256,uint256)' ], provider);
      const res  = await cert.quoteBatch(sizes);
      const total = res[0];
      $('fee').value = ethers.formatUnits(total, 18) + ' VLD';
      log(`Batch: ${hashes.length} files, ` + L.feeEstimated(ethers.formatUnits(total,18)));
      window._batch = { hashes, sizes, uris };
    }
  }catch(err){ log('Preview error: ' + (err?.message||err), '#ef4444'); }
});

$('approve').addEventListener('click', async ()=>{
  const L = I18N[document.documentElement.lang];
  try{
    if(needConnection()) return log(L.connectFirst, '#f59e0b');
    const vld  = new ethers.Contract(VLD_ADDR, [ 'function approve(address,uint256) external returns (bool)' ], signer);
    let amount;
    if($('mode').value==='single'){
      const f=$('file').files[0]; if(!f) return alert(L.selectAFile);
      const bytes = new Uint8Array(await f.arrayBuffer());
      const size = BigInt(bytes.length);
      const cert = new ethers.Contract(CONTRACT_ADDR, [ 'function quoteItem(uint64) view returns (uint256)' ], provider);
      amount = await cert.quoteItem(size);
    } else {
      if(!window._batch) return log('Run "Generate preview" first', '#f59e0b');
      const cert = new ethers.Contract(CONTRACT_ADDR, [ 'function quoteBatch(uint64[]) view returns (uint256,uint256)' ], provider);
      amount = (await cert.quoteBatch(window._batch.sizes))[0];
    }
    log(L.approveProgress);
    const tx = await vld.approve(CONTRACT_ADDR, amount);
    await tx.wait();
    log(L.approveOk(tx.hash), '#22c55e');
  }catch(err){ log('Approve error: ' + (err?.shortMessage||err?.message||err), '#ef4444'); }
});

$('mint').addEventListener('click', async ()=>{
  const L = I18N[document.documentElement.lang];
  try{
    if(needConnection()) return log(L.connectFirst, '#f59e0b');
    const cert = new ethers.Contract(CONTRACT_ADDR, [
      'function certify(bytes32,uint64,string) external',
      'function certifyBatch(bytes32[],uint64[],string[]) external'
    ], signer);

    if($('mode').value==='single'){
      const f=$('file').files[0]; if(!f) return alert(L.selectAFile);
      const bytes = new Uint8Array(await f.arrayBuffer());
      const hash = ethers.keccak256(bytes);
      const size = BigInt(bytes.length);
      const uri  = buildMetaURIWithFallback(hash, size);
      log(L.mintSingle);
      const tx = await cert.certify(hash, size, uri);
      await tx.wait();
      log(L.mintOk(tx.hash), '#22c55e');
    } else {
      if(!window._batch){ return log('Run "Generate preview" first', '#f59e0b'); }
      const {hashes, sizes, uris} = window._batch;
      log(L.mintBatch(hashes.length));
      const tx = await cert.certifyBatch(hashes, sizes, uris);
      await tx.wait();
      log(L.mintOk(tx.hash), '#22c55e');
    }
  }catch(err){ log('Mint error: ' + (err?.shortMessage||err?.message||err), '#ef4444'); }
});
</script>
</body>
</html>
